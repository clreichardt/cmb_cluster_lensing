import numpy as np, os, flatsky, tools
import scipy as sc
import scipy.ndimage as ndimage
from pylab import *

h, k_B, c=6.626e-34,1.38e-23, 3e8
data_folder = 'data/'

def get_foreground_power_spt(component, freq1=150, freq2=None, units='uk', lmax = None):
    """
    Foreground powers from George et al. 2015 results.

    Uses .sav file generated by Christain Reichardt.

    Parameters
    ----------
    component : str
        The foreground component to use. Must be one of
        'all', 'tSZ', 'kSZ', 'DG-Cl', 'DG-Po', 'RG', 'tSZ-CIB', 'Total', 'CMB'
    freq1 : int
        Frequency band. If `freq2` is specified, the cross-spectrum between
        the two frequencies will be returned. Otherwise autospectrum of freq1.
    freq2 : int, optional
        Frequency band for cross-spectrum with `freq1`
    units : str
        'k' or 'uk'. Note: default savfile is Dls in uK

    Returns
    -------
    fgnd_cls : array
        Power spectrum of `component` at specified frequency band.
    """
    components = [
        'all',
        'tSZ',
        'kSZ',
        'DG-Cl',
        'DG-Po',
        'RG',
        'tSZ-CIB',
        'Total',
        'CMB',
    ]
    if component not in components:
        raise ValueError(
            '{} not in list of possible foregrounds, must be one of {}'.format(
                component, components
            )
        )

    #filename = os.path.join(
    #    os.path.dirname(__file__), 'data/foregrounds/george_plot_bestfit_line.sav'
    #)

    #fix me: file / folder path
    from scipy.io import readsav
    try:
        filename = 'data/foregrounds/george_plot_bestfit_line.sav'
        data = readsav(filename)
    except:
        filename = '%s/foregrounds/george_plot_bestfit_line.sav' %(data_folder)
        data = readsav(filename)


    #from IPython import embed; embed()
    if freq2 is None:
        freq2 = freq1
    if freq1 == 90:
        freq1 = 95
    if freq2 == 90:
        freq2 = 95

    freqs = np.asarray(
        [(95, 95), (95, 150), (95, 220), (150, 150), (150, 220), (220, 220)]
    )
    dl_all = data['ml_dls'][(freqs[:, 0] == freq1) & (freqs[:, 1] == freq2)][0]
    labels = data['ml_dl_labels'].astype('str')
    el = np.asarray(data['ml_l'], dtype=int)

    if component == 'all':
        spec = el * 0.0
        for fg in components:
            if fg in ['all', 'tSZ-CIB', 'Total', 'CMB']:
                continue
            spec += dl_all[labels == fg][0]
    else:
        spec = dl_all[labels == component][0]

    # Changing Dls to Cls
    spec /= el * (el + 1.0) / 2.0 / np.pi
    if units.lower() == 'k':
        spec /= 1e12

    # Pad to l=0
    spec = np.concatenate((np.zeros(min(el)), spec))
    el = np.concatenate((np.arange(min(el)), el))

    if lmax is not None:
        el = el[:lmax]
        spec = spec[:lmax]

    return el, spec

def coth(x):
    return (np.exp(x) + np.exp(-x)) / (np.exp(x) - np.exp(-x))

def compton_y_to_delta_Tcmb(freq1, freq2 = None, Tcmb = 2.73):

    """ad
    c.f:  table 1, sec. 3 of arXiv: 1303.5081; 
    table 8 of http://arxiv.org/pdf/1303.5070.pdf
    no relativistic corrections included.
    freq1, freq2 = frequencies in GHz to cover the bandpass
    freq2 = None will force freq1 to be the centre frequency
    """

    if freq1<1e4: freq1 = freq1 * 1e9

    if not freq2 is None:
        if freq2<1e4: freq2 = freq2 * 1e9
        freq = np.arange(freq1,freq2,delta_nu)
    else:
        freq = np.asarray([freq1])

    x = (h * freq) / (k_B * Tcmb)
    g_nu = x * coth(x/2.) - 4.

    return Tcmb * np.mean(g_nu)

def get_mdpl2_cluster_tsz_ksz(total, reqd_dx, return_tsz = True, return_ksz = True, freq = 150):

    fname = '%s/foregrounds/mdpl2/mdpl2_cutouts_for_tszksz_clus_detection_M1.7e+14to2.3e+14_z0.6to0.8_15320haloes_boxsize10.0am_dx0.5am.npz' %(data_folder)
    mdpl2_cutout_size_am = 10.
    mdpl2_dx = 0.5 #arcmins
    ds_fac = int(reqd_dx/mdpl2_dx)
    cutouts_dic = np.load(fname, allow_pickle = 1, encoding= 'latin1')['arr_0'].item()
    #print(cutouts_dic.keys()) #(mass_bin_centre in M500c in 10^14 solar mass units, redshift)

    #mass_z_key = (2.0, 0.7)
    mass_z_key = list(cutouts_dic.keys())[0]
    cutouts = cutouts_dic[mass_z_key]

    total_mdpl2 = len(cutouts)
    rand_inds = np.random.choice(total_mdpl2, total, replace = total>total_mdpl2)
    
    y_cutouts, ksz_cutouts = [], []
    for kcntr, keyname in enumerate( cutouts ):
        if kcntr not in rand_inds: continue
        #print(keyname) #(ra, dec, redshift, M500c in 10^14 solar mass units)
        curr_y = cutouts[keyname]['y']
        curr_ksz = cutouts[keyname]['ksz']
        if ds_fac != 1:
            curr_y = tools.downsample_map(curr_y, ds_fac)
            curr_ksz = tools.downsample_map(curr_ksz, ds_fac)
        if (1): #rotate cutouts
            curr_y = tools.rotate_cutout(curr_y, np.random.random() * 360.)
            curr_ksz = tools.rotate_cutout(curr_ksz, np.random.random() * 360.)
        y_cutouts.append( curr_y )
        ksz_cutouts.append( curr_ksz )

    y_cutouts = np.asarray(y_cutouts)
    ksz_cutouts = np.asarray(ksz_cutouts)

    tsz_scalefac = compton_y_to_delta_Tcmb(freq)
    tsz_cutouts = np.copy(y_cutouts) * tsz_scalefac * 1e6
    
    mdpl2_dic = {}
    if return_tsz:
        mdpl2_dic['tsz'] = tsz_cutouts
    if return_ksz:
        mdpl2_dic['ksz'] = ksz_cutouts

    if (0):
        ksz_cutouts_abs = np.abs(ksz_cutouts)
        stacked_y = np.mean(y_cutouts, axis = 0) #use compton_y_to_delta_Tcmb(freq*1e9, Tcmb = 2.73) to convert ymap into tSZ map at the desired frequency.
        stacked_ksz = np.mean(ksz_cutouts, axis = 0)
        stacked_ksz_abs = np.mean(ksz_cutouts_abs, axis = 0)
        print(ksz_cutouts_abs.shape)

        ny, nx = stacked_y.shape
        #boxsize_am = 121. #arcmins
        xmin = -nx*dx/2.
        xmax = -xmin


        subplot(131); imshow(stacked_y, extent = [xmin, xmax, xmin, xmax]); colorbar(); axhline(lw = 0.5); axvline(lw = 0.5); title(r'Compton-y')
        subplot(132); imshow(stacked_ksz, extent = [xmin, xmax, xmin, xmax]); colorbar(); axhline(lw = 0.5); axvline(lw = 0.5); title(r'kSZ')
        subplot(133); imshow(stacked_ksz_abs, extent = [xmin, xmax, xmin, xmax]); colorbar(); axhline(lw = 0.5); axvline(lw = 0.5); title(r'abs(kSZ)')
        show(); sys.exit()

    return mdpl2_dic, mdpl2_cutout_size_am

def fitfunc(p, radius):
    return p[0] + p[1] * ( 1.0 + (radius/p[2]) ** 2. ) ** (0.5 - (1.5 * p[3]) )

def tsz_beta_model_fitting_func(p, p0, radius, data = None, lbounds = None, ubounds = None, fixed = None, return_fit = 0):            

    #fitfunc = lambda p, radius: p[0] + p[1] * ( 1.0 + (radius/p[2]) ** 2. ) ** (0.5 - (1.5 * p[3]) )

    if hasattr(fixed, '__len__'):                
        p[fixed] = p0[fixed]

    if hasattr(lbounds, '__len__'):
        lbounds = np.asarray(lbounds)
        linds = abs(p)<abs(lbounds)
        p[linds] = lbounds[linds]

    if hasattr(ubounds, '__len__'):
        ubounds = np.asarray(ubounds)
        uinds = abs(p)>abs(ubounds)
        p[uinds] = ubounds[uinds]

    if not return_fit:
        return np.ravel(fitfunc(p, radius) - data)
    else:
        return fitfunc(p, radius)

def fit_fot_tsz(cutout, dx, cluster_rad_am = 1.5):
    import scipy.optimize as optimize

    ny, nx = cutout.shape
    x1, x2 = -nx/2. * dx, nx/2. *dx
    x = np.linspace(x1, x2, nx)
    ra_grid, dec_grid = np.meshgrid(x, x)
    radius_am = np.hypot(ra_grid, dec_grid)
    inside_inds = np.where((radius_am<=cluster_rad_am))
    ini_amp = np.mean( cutout[inside_inds] )

    outside_inds = np.where((radius_am>=2*cluster_rad_am))
    ini_bg = np.mean( cutout[outside_inds] )

    ini_theta_core = 1. #arcmin
    ini_beta_value = 1.

    p0 = [ini_bg, ini_amp, ini_theta_core, ini_beta_value]
    minamp, maxamp = ini_amp * 4., ini_amp * 0.5

    lbounds = None#[ini_bg*0.5, minamp, .25, 0.8]
    ubounds = None#[ini_bg*4., maxamp, 1.5, 1.3]

    p1, success = optimize.leastsq(tsz_beta_model_fitting_func, p0[:], args=(p0, radius_am, cutout, lbounds, ubounds))
    tsz_fit = fitfunc(p1, radius_am)
    #print(p0, p1)

    return tsz_fit
